<Query Kind="Program">
  <Connection>
    <ID>49598a36-613b-4feb-9d96-3edf2a6c4920</ID>
    <NamingServiceVersion>2</NamingServiceVersion>
    <Persist>true</Persist>
    <Server>localhost\sqlexpress</Server>
    <AllowDateOnlyTimeOnly>true</AllowDateOnlyTimeOnly>
    <Database>BlazorBlogDb</Database>
    <DriverData>
      <LegacyMFA>false</LegacyMFA>
    </DriverData>
  </Connection>
  <NuGetReference>Microsoft.Data.SqlClient</NuGetReference>
</Query>

#nullable enable
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using SqlConnection = Microsoft.Data.SqlClient.SqlConnection;
using SqlCommand = Microsoft.Data.SqlClient.SqlCommand;

// ─────────────────────────────────────────────
// MAIN
// ─────────────────────────────────────────────
void Main()
{
	var connectionString = this.Connection.ConnectionString;

	var outputRoot = @"C:\dev\SqlCrudProcs";
	Directory.CreateDirectory(outputRoot);

	// ──────────────────────────────── CONFIG ────────────────────────────────
	var options = new ProcGenOptions
	{
		UseUspPrefix = true,
		PluralizeProcNames = false,
		ProcSchemaOverride = "api",              // null = use table schema
		ProcNameSuffix = "",
		InsertReturnMode = InsertReturnMode.ScopeIdentity,
		UpsertMode = UpsertMode.UpdateThenInsert,
		IncludeDropStatements = true,
		IncludeSelectAll = true,
		IncludeSearchProc = true,
		IncludeRowsAffected = true,

		EnableSoftDelete = true,
		IncludeUnDeleteProc = true,
		IncludePurgeProc = false,

		EnableAuditTrail = true
	};

	string[] includeSchemaPatterns = Array.Empty<string>();
	string[] excludeSchemaPatterns = Array.Empty<string>();
	string[] includeTablePatterns = Array.Empty<string>();
	string[] excludeTablePatterns = { "__EFMigrationsHistory" };

	using var cx = new SqlConnection(connectionString);
	cx.Open();

	var tables = LoadTables(cx)
		.Where(t => MatchesPatterns(t.Schema, includeSchemaPatterns, true)
				 && !MatchesPatterns(t.Schema, excludeSchemaPatterns, false)
				 && MatchesPatterns(t.Name, includeTablePatterns, true)
				 && !MatchesPatterns(t.Name, excludeTablePatterns, false))
		.OrderBy(t => t.Schema).ThenBy(t => t.Name)
		.ToList();

	if (tables.Count == 0)
	{
		"No tables matched filters.".Dump();
		return;
	}

	var all = new StringBuilder();
	all.AppendLine("-- =================================================");
	all.AppendLine("-- Auto-generated CRUD + UPSERT + Soft-Delete + Audit Trail Procedures");
	all.AppendLine("-- Generated by LINQPad 9 Script");
	all.AppendLine("-- Date: " + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"));
	all.AppendLine("-- =================================================");
	all.AppendLine();

	int generated = 0, skipped = 0;

	foreach (var t in tables)
	{
		var columns = LoadColumns(cx, t.Schema, t.Name);
		var pk = LoadPrimaryKey(cx, t.Schema, t.Name);

		if (pk.Count == 0)
		{
			skipped++;
			all.AppendLine($"-- SKIP: [{t.Schema}].[{t.Name}] (no primary key)");
			all.AppendLine();
			continue;
		}

		var script = GenerateCrudForTable(options, t.Schema, t.Name, columns, pk);
		var fileName = $"{t.Schema}.{t.Name}.CrudProcs{options.ProcNameSuffix}.sql";
		File.WriteAllText(Path.Combine(outputRoot, fileName), script, Encoding.UTF8);

		all.AppendLine(script);
		all.AppendLine("GO");
		all.AppendLine();

		generated++;
	}

	File.WriteAllText(Path.Combine(outputRoot, $"AllProcs{options.ProcNameSuffix}.sql"), all.ToString(), Encoding.UTF8);

	$"Done. Generated: {generated}, Skipped (no PK): {skipped}\nOutput: {outputRoot}".Dump();
}

// ─────────────────────────────────────────────
// OPTIONS
// ─────────────────────────────────────────────
sealed class ProcGenOptions
{
	public bool UseUspPrefix { get; init; } = true;
	public string? ProcSchemaOverride { get; init; } = null;
	public bool PluralizeProcNames { get; init; } = false;
	public string ProcNameSuffix { get; init; } = "";
	public InsertReturnMode InsertReturnMode { get; init; } = InsertReturnMode.ScopeIdentity;
	public UpsertMode UpsertMode { get; init; } = UpsertMode.UpdateThenInsert;
	public bool IncludeDropStatements { get; init; } = true;
	public bool IncludeSelectAll { get; init; } = false;
	public bool IncludeSearchProc { get; init; } = false;
	public bool IncludeRowsAffected { get; init; } = true;

	public bool EnableSoftDelete { get; init; } = true;
	public bool IncludeUnDeleteProc { get; init; } = true;
	public bool IncludePurgeProc { get; init; } = false;

	public bool EnableAuditTrail { get; init; } = true;
}

enum InsertReturnMode { ScopeIdentity, OutputInserted }
enum UpsertMode { UpdateThenInsert, UpdateOnlyThrow }

// ─────────────────────────────────────────────
// SCHEMA MODELS
// ─────────────────────────────────────────────
sealed record TableInfo(string Schema, string Name);
sealed record ColumnInfo(
	string Name,
	string SqlType,
	int? MaxLength,
	byte Precision,
	int Scale,
	bool IsNullable,
	bool IsIdentity,
	bool IsComputed,
	bool IsRowVersion,
	bool IsGeneratedAlways,
	string? CollationName);

// ─────────────────────────────────────────────
// METADATA QUERIES
// ─────────────────────────────────────────────
static List<TableInfo> LoadTables(SqlConnection cx)
{
	const string sql = @"
        SELECT s.name AS [Schema], t.name AS [Table] 
        FROM sys.tables t 
        JOIN sys.schemas s ON s.schema_id = t.schema_id 
        WHERE t.is_ms_shipped = 0 
        ORDER BY s.name, t.name;";

	using var cmd = new SqlCommand(sql, cx);
	using var rdr = cmd.ExecuteReader();
	var list = new List<TableInfo>();
	while (rdr.Read()) list.Add(new TableInfo(rdr.GetString(0), rdr.GetString(1)));
	return list;
}

static List<ColumnInfo> LoadColumns(SqlConnection cx, string schema, string table)
{
	const string sql = @"
        SELECT 
            c.name, ty.name, c.max_length, c.precision, c.scale,
            c.is_nullable, c.is_identity, c.is_computed, c.generated_always_type, c.collation_name
        FROM sys.tables t
        JOIN sys.schemas s ON s.schema_id = t.schema_id
        JOIN sys.columns c ON c.object_id = t.object_id
        JOIN sys.types ty ON ty.user_type_id = c.user_type_id
        WHERE s.name = @schema AND t.name = @table
        ORDER BY c.column_id;";

	using var cmd = new SqlCommand(sql, cx);
	cmd.Parameters.AddWithValue("@schema", schema);
	cmd.Parameters.AddWithValue("@table", table);
	using var rdr = cmd.ExecuteReader();
	var list = new List<ColumnInfo>();
	while (rdr.Read())
	{
		var typeName = rdr.GetString(1);
		var isRowVersion = typeName.Equals("timestamp", StringComparison.OrdinalIgnoreCase);

		list.Add(new ColumnInfo(
			Name: rdr.GetString(0),
			SqlType: typeName,
			MaxLength: rdr.IsDBNull(2) ? null : rdr.GetInt16(2),
			Precision: rdr.IsDBNull(3) ? (byte)0 : rdr.GetByte(3),
			Scale: rdr.IsDBNull(4) ? 0 : rdr.GetByte(4),
			IsNullable: rdr.GetBoolean(5),
			IsIdentity: rdr.GetBoolean(6),
			IsComputed: rdr.GetBoolean(7),
			IsRowVersion: isRowVersion,
			IsGeneratedAlways: !rdr.IsDBNull(8) && rdr.GetByte(8) != 0,
			CollationName: rdr.IsDBNull(9) ? null : rdr.GetString(9)
		));
	}
	return list;
}

static List<string> LoadPrimaryKey(SqlConnection cx, string schema, string table)
{
	const string sql = @"
        SELECT c.name
        FROM sys.tables t
        JOIN sys.schemas s ON s.schema_id = t.schema_id
        JOIN sys.key_constraints kc ON kc.parent_object_id = t.object_id AND kc.type = 'PK'
        JOIN sys.index_columns ic ON ic.object_id = t.object_id AND ic.index_id = kc.unique_index_id
        JOIN sys.columns c ON c.object_id = t.object_id AND c.column_id = ic.column_id
        WHERE s.name = @schema AND t.name = @table
        ORDER BY ic.key_ordinal;";

	using var cmd = new SqlCommand(sql, cx);
	cmd.Parameters.AddWithValue("@schema", schema);
	cmd.Parameters.AddWithValue("@table", table);
	using var rdr = cmd.ExecuteReader();
	var pk = new List<string>();
	while (rdr.Read()) pk.Add(rdr.GetString(0));
	return pk;
}

// ─────────────────────────────────────────────
// DETECTION HELPERS
// ─────────────────────────────────────────────
static (ColumnInfo? IsDeleted, ColumnInfo? DeletedAt, ColumnInfo? DeletedBy) DetectSoftDeleteColumns(List<ColumnInfo> cols)
{
	var isDeleted = cols.FirstOrDefault(c =>
		c.Name.Equals("IsDeleted", StringComparison.OrdinalIgnoreCase) &&
		c.SqlType.Equals("bit", StringComparison.OrdinalIgnoreCase));

	var deletedAt = cols.FirstOrDefault(c =>
		c.Name.Equals("DeletedAt", StringComparison.OrdinalIgnoreCase) ||
		c.Name.Equals("DeletedOn", StringComparison.OrdinalIgnoreCase));

	var deletedBy = cols.FirstOrDefault(c =>
		c.Name.Equals("DeletedBy", StringComparison.OrdinalIgnoreCase));

	return (isDeleted, deletedAt, deletedBy);
}

static (ColumnInfo? CreatedAt, ColumnInfo? CreatedBy, ColumnInfo? UpdatedAt, ColumnInfo? UpdatedBy) DetectAuditColumns(List<ColumnInfo> cols)
{
	var createdAt = cols.FirstOrDefault(c =>
		(c.Name.Equals("CreatedAt", StringComparison.OrdinalIgnoreCase) ||
		 c.Name.Equals("CreatedOn", StringComparison.OrdinalIgnoreCase)) &&
		c.SqlType.IndexOf("date", StringComparison.OrdinalIgnoreCase) >= 0);

	var createdBy = cols.FirstOrDefault(c => c.Name.Equals("CreatedBy", StringComparison.OrdinalIgnoreCase));

	var updatedAt = cols.FirstOrDefault(c =>
		(c.Name.Equals("UpdatedAt", StringComparison.OrdinalIgnoreCase) ||
		 c.Name.Equals("UpdatedOn", StringComparison.OrdinalIgnoreCase)) &&
		c.SqlType.IndexOf("date", StringComparison.OrdinalIgnoreCase) >= 0);

	var updatedBy = cols.FirstOrDefault(c => c.Name.Equals("UpdatedBy", StringComparison.OrdinalIgnoreCase));

	return (createdAt, createdBy, updatedAt, updatedBy);
}

// ─────────────────────────────────────────────
// AUDIT HELPERS
// ─────────────────────────────────────────────
static string GetAuditUserParam(ColumnInfo? createdBy, ColumnInfo? updatedBy)
{
	if (createdBy == null && updatedBy == null) return "";

	var sampleCol = createdBy ?? updatedBy!;
	var sqlType = sampleCol.SqlType.ToLowerInvariant();
	var paramType = sqlType.IndexOf("char", StringComparison.OrdinalIgnoreCase) >= 0 ? "nvarchar(100)" : "int";
	return $"@CurrentUser {paramType} = NULL";
}

// ─────────────────────────────────────────────
// GENERATION
// ─────────────────────────────────────────────
static string GenerateCrudForTable(ProcGenOptions options, string tableSchema, string tableName, List<ColumnInfo> cols, List<string> pkCols)
{
	var fullTable = $"[{tableSchema}].[{tableName}]";
	var procSchema = string.IsNullOrWhiteSpace(options.ProcSchemaOverride) ? tableSchema : options.ProcSchemaOverride!.Trim();
	var procTableName = options.PluralizeProcNames ? SimplePluralize(tableName) : tableName;
	var procPrefix = options.UseUspPrefix ? "usp_" : "";
	var procSuffix = options.ProcNameSuffix;
	var procBase = $"{procPrefix}{procTableName}{procSuffix}";

	var identityCol = cols.FirstOrDefault(c => c.IsIdentity);
	var rowVersionCol = cols.FirstOrDefault(c => c.IsRowVersion);

	var insertCols = cols.Where(c => !c.IsIdentity && !c.IsComputed && !c.IsRowVersion && !c.IsGeneratedAlways).ToList();
	var updateCols = cols.Where(c => !pkCols.Contains(c.Name, StringComparer.OrdinalIgnoreCase)
								&& !c.IsIdentity && !c.IsComputed && !c.IsRowVersion && !c.IsGeneratedAlways).ToList();
	var pkParams = pkCols.Select(pk => cols.First(c => c.Name.Equals(pk, StringComparison.OrdinalIgnoreCase))).ToList();

	var (isDeletedCol, deletedAtCol, deletedByCol) = DetectSoftDeleteColumns(cols);
	var hasSoftDelete = options.EnableSoftDelete && isDeletedCol != null;

	var (createdAtCol, createdByCol, updatedAtCol, updatedByCol) = DetectAuditColumns(cols);
	var hasAudit = options.EnableAuditTrail && (createdAtCol != null || createdByCol != null || updatedAtCol != null || updatedByCol != null);

	var sb = new StringBuilder();
	sb.AppendLine($"-- =====================================================");
	sb.AppendLine($"-- CRUD Procedures for {fullTable}");
	sb.AppendLine($"-- Soft-Delete: {(hasSoftDelete ? "Enabled" : "Disabled")} | Audit Trail: {(hasAudit ? "Enabled" : "Disabled")}");
	sb.AppendLine($"-- =====================================================");
	sb.AppendLine();

	Action<string, Action> AppendProc = (name, gen) =>
	{
		if (options.IncludeDropStatements)
			sb.AppendLine($"IF OBJECT_ID('[{procSchema}].[{name}]', 'P') IS NOT NULL DROP PROCEDURE [{procSchema}].[{name}];");
		sb.AppendLine("GO");
		sb.AppendLine();
		gen();
		sb.AppendLine("GO");
		sb.AppendLine();
	};

	AppendProc($"{procBase}_Insert", () => sb.AppendLine(GenInsertProc(options, procSchema, procBase, fullTable, insertCols, pkParams, identityCol, createdAtCol, createdByCol)));
	AppendProc($"{procBase}_Update", () => sb.AppendLine(GenUpdateProc(options, procSchema, procBase, fullTable, pkParams, updateCols, rowVersionCol, updatedAtCol, updatedByCol)));
	AppendProc($"{procBase}_Upsert", () => sb.AppendLine(GenUpsertProc(options, procSchema, procBase, fullTable, cols, pkParams, insertCols, updateCols, identityCol, rowVersionCol, hasSoftDelete, isDeletedCol, deletedAtCol, createdAtCol, createdByCol, updatedAtCol, updatedByCol)));

	if (hasSoftDelete)
		AppendProc($"{procBase}_Delete", () => sb.AppendLine(GenSoftDeleteProc(options, procSchema, procBase, fullTable, pkParams, rowVersionCol, isDeletedCol!, deletedAtCol, deletedByCol, updatedAtCol, updatedByCol)));
	else
		AppendProc($"{procBase}_Delete", () => sb.AppendLine(GenDeleteProc(options, procSchema, procBase, fullTable, pkParams, rowVersionCol)));

	AppendProc($"{procBase}_GetById", () => sb.AppendLine(GenGetByIdProc(procSchema, procBase, fullTable, pkParams, hasSoftDelete, isDeletedCol)));
	AppendProc($"{procBase}_ListPaged", () => sb.AppendLine(GenListPagedProc(options, procSchema, procBase, fullTable, cols, pkParams, hasSoftDelete, isDeletedCol)));

	if (options.IncludeSelectAll)
		AppendProc($"{procBase}_SelectAll", () => sb.AppendLine(GenSelectAllProc(procSchema, procBase, fullTable, hasSoftDelete, isDeletedCol)));

	if (options.IncludeSearchProc)
		AppendProc($"{procBase}_Search", () => sb.AppendLine(GenSearchProc(procSchema, procBase, fullTable, cols, hasSoftDelete, isDeletedCol)));

	if (hasSoftDelete)
	{
		if (options.IncludeUnDeleteProc)
			AppendProc($"{procBase}_UnDelete", () => sb.AppendLine(GenUnDeleteProc(procSchema, procBase, fullTable, pkParams, isDeletedCol!, deletedAtCol, deletedByCol, updatedAtCol, updatedByCol)));

		if (options.IncludePurgeProc)
			AppendProc($"{procBase}_Purge", () => sb.AppendLine(GenPurgeProc(options, procSchema, procBase, fullTable, pkParams, rowVersionCol)));
	}

	return sb.ToString();
}

// ─────────────────────────────────────────────
// PROC GENERATORS
// ─────────────────────────────────────────────
static string GenInsertProc(ProcGenOptions options, string procSchema, string procBase, string fullTable,
	List<ColumnInfo> insertCols, List<ColumnInfo> pkParams, ColumnInfo? identityCol,
	ColumnInfo? createdAt, ColumnInfo? createdBy)
{
	var proc = $"[{procSchema}].[{procBase}_Insert]";
	var parameters = insertCols.Select(ParamDecl).ToList();

	bool returnIdentity = identityCol != null && pkParams.Count == 1 && pkParams[0].Name.Equals(identityCol.Name, StringComparison.OrdinalIgnoreCase);
	if (returnIdentity && options.InsertReturnMode == InsertReturnMode.ScopeIdentity)
		parameters.Add($"@NewId {SqlTypeDecl(identityCol!)} OUTPUT");

	if (createdBy != null)
		parameters.Add(GetAuditUserParam(createdBy, null));

	var sb = new StringBuilder();
	sb.AppendLine($"CREATE OR ALTER PROCEDURE {proc}");
	if (parameters.Any()) sb.AppendLine("    " + string.Join(",\r\n    ", parameters));
	sb.AppendLine("AS");
	sb.AppendLine("BEGIN");
	sb.AppendLine("    SET NOCOUNT ON; SET XACT_ABORT ON;");
	sb.AppendLine("    BEGIN TRY");
	sb.AppendLine("        BEGIN TRAN;");

	var insertFields = new List<string>(insertCols.Select(c => $"[{c.Name}]"));
	var insertValues = new List<string>(insertCols.Select(c => $"@{c.Name}"));

	if (createdAt != null)
	{
		insertFields.Add($"[{createdAt.Name}]");
		insertValues.Add("SYSUTCDATETIME()");
	}
	if (createdBy != null)
	{
		insertFields.Add($"[{createdBy.Name}]");
		insertValues.Add("@CurrentUser");
	}

	sb.AppendLine($"        INSERT INTO {fullTable} ({string.Join(", ", insertFields)})");
	sb.AppendLine($"        VALUES ({string.Join(", ", insertValues)});");

	if (returnIdentity && options.InsertReturnMode == InsertReturnMode.ScopeIdentity)
	{
		sb.AppendLine($"        SET @NewId = SCOPE_IDENTITY();");
		sb.AppendLine($"        SELECT * FROM {fullTable} WHERE [{identityCol!.Name}] = @NewId;");
		sb.AppendLine("        SELECT @NewId AS NewId;");
	}

	sb.AppendLine("        COMMIT;");
	sb.AppendLine("    END TRY");
	sb.AppendLine("    BEGIN CATCH");
	sb.AppendLine("        IF @@TRANCOUNT > 0 ROLLBACK; THROW;");
	sb.AppendLine("    END CATCH");
	sb.AppendLine("END");
	return sb.ToString();
}

static string GenUpdateProc(ProcGenOptions options, string procSchema, string procBase, string fullTable,
	List<ColumnInfo> pkParams, List<ColumnInfo> updateCols, ColumnInfo? rowVersionCol,
	ColumnInfo? updatedAt, ColumnInfo? updatedBy)
{
	var proc = $"[{procSchema}].[{procBase}_Update]";
	var parameters = pkParams.Select(ParamDecl).ToList();
	if (rowVersionCol != null) parameters.Add($"@RowVersion {SqlTypeDecl(rowVersionCol)}");
	if (updatedBy != null) parameters.Add(GetAuditUserParam(null, updatedBy));
	parameters.AddRange(updateCols.Select(ParamDecl));

	var wherePk = string.Join(" AND ", pkParams.Select(c => $"t.[{c.Name}] = @{c.Name}"));

	var sb = new StringBuilder();
	sb.AppendLine($"CREATE OR ALTER PROCEDURE {proc}");
	sb.AppendLine("    " + string.Join(",\r\n    ", parameters));
	sb.AppendLine("AS");
	sb.AppendLine("BEGIN");
	sb.AppendLine("    SET NOCOUNT ON; SET XACT_ABORT ON;");
	sb.AppendLine("    BEGIN TRY");
	sb.AppendLine("        BEGIN TRAN;");

	sb.AppendLine("        UPDATE t SET");
	var setLines = new List<string>(updateCols.Select(c => $"            [{c.Name}] = @{c.Name}"));
	if (updatedAt != null) setLines.Add($"            [{updatedAt.Name}] = SYSUTCDATETIME()");
	if (updatedBy != null) setLines.Add($"            [{updatedBy.Name}] = @CurrentUser");
	sb.AppendLine(string.Join(",\r\n", setLines));
	sb.AppendLine($"        FROM {fullTable} t");
	sb.Append("        WHERE ").Append(wherePk);
	if (rowVersionCol != null) sb.Append($" AND t.[{rowVersionCol.Name}] = @RowVersion");
	sb.AppendLine(";");

	sb.AppendLine("        IF @@ROWCOUNT = 0 THROW 50002, 'Update failed (not found or concurrency conflict).', 1;");

	if (options.IncludeRowsAffected)
		sb.AppendLine("        SELECT @@ROWCOUNT AS RowsAffected;");

	sb.AppendLine("        COMMIT;");
	sb.AppendLine("    END TRY");
	sb.AppendLine("    BEGIN CATCH");
	sb.AppendLine("        IF @@TRANCOUNT > 0 ROLLBACK; THROW;");
	sb.AppendLine("    END CATCH");
	sb.AppendLine("END");
	return sb.ToString();
}

static string GenSoftDeleteProc(ProcGenOptions options, string procSchema, string procBase, string fullTable,
	List<ColumnInfo> pkParams, ColumnInfo? rowVersionCol, ColumnInfo isDeletedCol, ColumnInfo? deletedAtCol, ColumnInfo? deletedByCol,
	ColumnInfo? updatedAt, ColumnInfo? updatedBy)
{
	var proc = $"[{procSchema}].[{procBase}_Delete]";
	var parameters = pkParams.Select(ParamDecl).ToList();
	if (rowVersionCol != null) parameters.Add($"@RowVersion {SqlTypeDecl(rowVersionCol)}");
	if (updatedBy != null || deletedByCol != null) parameters.Add(GetAuditUserParam(null, updatedBy ?? deletedByCol));

	var wherePk = string.Join(" AND ", pkParams.Select(c => $"t.[{c.Name}] = @{c.Name}"));

	var sb = new StringBuilder();
	sb.AppendLine($"-- Soft Delete");
	sb.AppendLine($"CREATE OR ALTER PROCEDURE {proc}");
	sb.AppendLine("    " + string.Join(",\r\n    ", parameters));
	sb.AppendLine("AS");
	sb.AppendLine("BEGIN");
	sb.AppendLine("    SET NOCOUNT ON; SET XACT_ABORT ON;");
	sb.AppendLine("    BEGIN TRY");
	sb.AppendLine("        BEGIN TRAN;");

	sb.AppendLine("        UPDATE t SET");
	var setLines = new List<string> { $"            [{isDeletedCol.Name}] = 1" };
	if (deletedAtCol != null) setLines.Add($"            [{deletedAtCol.Name}] = SYSUTCDATETIME()");
	if (deletedByCol != null) setLines.Add($"            [{deletedByCol.Name}] = @CurrentUser");
	if (updatedAt != null) setLines.Add($"            [{updatedAt.Name}] = SYSUTCDATETIME()");
	if (updatedBy != null) setLines.Add($"            [{updatedBy.Name}] = @CurrentUser");
	sb.AppendLine(string.Join(",\r\n", setLines));
	sb.AppendLine($"        FROM {fullTable} t");
	sb.Append("        WHERE ").Append(wherePk);
	if (rowVersionCol != null) sb.Append($" AND t.[{rowVersionCol.Name}] = @RowVersion");
	sb.AppendLine(";");

	sb.AppendLine("        IF @@ROWCOUNT = 0 THROW 50003, 'Soft-delete failed (not found or concurrency conflict).', 1;");

	if (options.IncludeRowsAffected)
		sb.AppendLine("        SELECT @@ROWCOUNT AS RowsAffected;");

	sb.AppendLine("        COMMIT;");
	sb.AppendLine("    END TRY");
	sb.AppendLine("    BEGIN CATCH");
	sb.AppendLine("        IF @@TRANCOUNT > 0 ROLLBACK; THROW;");
	sb.AppendLine("    END CATCH");
	sb.AppendLine("END");
	return sb.ToString();
}

static string GenUnDeleteProc(string procSchema, string procBase, string fullTable,
	List<ColumnInfo> pkParams, ColumnInfo isDeletedCol, ColumnInfo? deletedAtCol, ColumnInfo? deletedByCol,
	ColumnInfo? updatedAt, ColumnInfo? updatedBy)
{
	var proc = $"[{procSchema}].[{procBase}_UnDelete]";
	var parameters = pkParams.Select(ParamDecl).ToList();
	if (updatedBy != null) parameters.Add(GetAuditUserParam(null, updatedBy));

	var wherePk = string.Join(" AND ", pkParams.Select(c => $"t.[{c.Name}] = @{c.Name}"));

	var sb = new StringBuilder();
	sb.AppendLine($"-- Restore soft-deleted row");
	sb.AppendLine($"CREATE OR ALTER PROCEDURE {proc}");
	sb.AppendLine("    " + string.Join(",\r\n    ", parameters));
	sb.AppendLine("AS");
	sb.AppendLine("BEGIN");
	sb.AppendLine("    SET NOCOUNT ON; SET XACT_ABORT ON;");

	sb.AppendLine("    UPDATE t SET");
	var setLines = new List<string> { $"        [{isDeletedCol.Name}] = 0" };
	if (deletedAtCol != null) setLines.Add($"        [{deletedAtCol.Name}] = NULL");
	if (deletedByCol != null) setLines.Add($"        [{deletedByCol.Name}] = NULL");
	if (updatedAt != null) setLines.Add($"        [{updatedAt.Name}] = SYSUTCDATETIME()");
	if (updatedBy != null) setLines.Add($"        [{updatedBy.Name}] = @CurrentUser");
	sb.AppendLine(string.Join(",\r\n", setLines));
	sb.AppendLine($"    FROM {fullTable} t");
	sb.AppendLine($"    WHERE {wherePk};");

	sb.AppendLine("    SELECT @@ROWCOUNT AS RowsAffected;");
	sb.AppendLine("END");
	return sb.ToString();
}

static string GenUpsertProc(ProcGenOptions options, string procSchema, string procBase, string fullTable,
	List<ColumnInfo> allCols, List<ColumnInfo> pkParams, List<ColumnInfo> insertCols, List<ColumnInfo> updateCols,
	ColumnInfo? identityCol, ColumnInfo? rowVersionCol, bool hasSoftDelete, ColumnInfo? isDeletedCol, ColumnInfo? deletedAtCol,
	ColumnInfo? createdAt, ColumnInfo? createdBy, ColumnInfo? updatedAt, ColumnInfo? updatedBy)
{
	var proc = $"[{procSchema}].[{procBase}_Upsert]";
	bool singleIdentityPk = identityCol != null && pkParams.Count == 1 && pkParams[0].Name.Equals(identityCol.Name, StringComparison.OrdinalIgnoreCase);

	var parameters = new List<string>();
	if (singleIdentityPk)
		parameters.Add($"@{identityCol!.Name} {SqlTypeDecl(identityCol)} = NULL");
	else
		parameters.AddRange(pkParams.Select(ParamDecl));

	if (rowVersionCol != null) parameters.Add($"@RowVersion {SqlTypeDecl(rowVersionCol)} = NULL");

	if (createdBy != null || updatedBy != null)
		parameters.Add(GetAuditUserParam(createdBy, updatedBy));

	var dataCols = insertCols.Concat(updateCols).GroupBy(c => c.Name, StringComparer.OrdinalIgnoreCase).Select(g => g.First()).ToList();
	parameters.AddRange(dataCols.Select(ParamDecl));

	var wherePk = singleIdentityPk ? $"t.[{identityCol!.Name}] = @{identityCol!.Name}" : string.Join(" AND ", pkParams.Select(c => $"t.[{c.Name}] = @{c.Name}"));
	var concurrency = rowVersionCol != null ? $" AND (@RowVersion IS NULL OR t.[{rowVersionCol.Name}] = @RowVersion)" : "";

	var sb = new StringBuilder();
	sb.AppendLine($"CREATE OR ALTER PROCEDURE {proc}");
	sb.AppendLine("    " + string.Join(",\r\n    ", parameters));
	sb.AppendLine("AS");
	sb.AppendLine("BEGIN");
	sb.AppendLine("    SET NOCOUNT ON; SET XACT_ABORT ON;");
	sb.AppendLine("    BEGIN TRY");
	sb.AppendLine("        BEGIN TRAN;");

	// Try UPDATE first (including restoring soft-deleted rows)
	var hasUpdateLogic = updateCols.Any() || hasSoftDelete || updatedAt != null || updatedBy != null;
	if (hasUpdateLogic)
	{
		sb.AppendLine("        UPDATE t SET");
		var updateSets = new List<string>(updateCols.Select(c => $"            [{c.Name}] = @{c.Name}"));
		if (hasSoftDelete) updateSets.Add($"            [{isDeletedCol!.Name}] = 0");
		if (deletedAtCol != null) updateSets.Add($"            [{deletedAtCol.Name}] = NULL");
		if (updatedAt != null) updateSets.Add($"            [{updatedAt.Name}] = SYSUTCDATETIME()");
		if (updatedBy != null) updateSets.Add($"            [{updatedBy.Name}] = @CurrentUser");
		sb.AppendLine(string.Join(",\r\n", updateSets));
		sb.AppendLine($"        FROM {fullTable} t");
		sb.AppendLine($"        WHERE {wherePk}{concurrency};");
		sb.AppendLine();
		sb.AppendLine("        IF @@ROWCOUNT = 0");
		sb.AppendLine("        BEGIN");
		if (options.UpsertMode == UpsertMode.UpdateOnlyThrow)
			sb.AppendLine("            THROW 50010, 'Upsert failed: row not found or concurrency conflict.', 1;");
		else
		{
			// INSERT new row
			var insertFields = new List<string>(insertCols.Select(c => $"[{c.Name}]"));
			var insertValues = new List<string>(insertCols.Select(c => $"@{c.Name}"));
			if (createdAt != null) { insertFields.Add($"[{createdAt.Name}]"); insertValues.Add("SYSUTCDATETIME()"); }
			if (createdBy != null) { insertFields.Add($"[{createdBy.Name}]"); insertValues.Add("@CurrentUser"); }
			sb.AppendLine($"            INSERT INTO {fullTable} ({string.Join(", ", insertFields)})");
			sb.AppendLine($"            VALUES ({string.Join(", ", insertValues)});");

			if (singleIdentityPk)
				sb.AppendLine($"            SET @{identityCol!.Name} = SCOPE_IDENTITY();");
		}
		sb.AppendLine("        END");
	}
	else
	{
		// No update columns — just insert
		var insertFields = new List<string>(insertCols.Select(c => $"[{c.Name}]"));
		var insertValues = new List<string>(insertCols.Select(c => $"@{c.Name}"));
		if (createdAt != null) { insertFields.Add($"[{createdAt.Name}]"); insertValues.Add("SYSUTCDATETIME()"); }
		if (createdBy != null) { insertFields.Add($"[{createdBy.Name}]"); insertValues.Add("@CurrentUser"); }
		sb.AppendLine($"        INSERT INTO {fullTable} ({string.Join(", ", insertFields)})");
		sb.AppendLine($"        VALUES ({string.Join(", ", insertValues)});");
		if (singleIdentityPk)
			sb.AppendLine($"        SET @{identityCol!.Name} = SCOPE_IDENTITY();");
	}

	sb.AppendLine($"        SELECT * FROM {fullTable} t WHERE {wherePk}");
	if (hasSoftDelete) sb.AppendLine($"        AND t.[{isDeletedCol!.Name}] = 0");

	if (options.IncludeRowsAffected)
		sb.AppendLine("        SELECT 1 AS RowsAffected;");

	sb.AppendLine("        COMMIT;");
	sb.AppendLine("    END TRY");
	sb.AppendLine("    BEGIN CATCH");
	sb.AppendLine("        IF @@TRANCOUNT > 0 ROLLBACK; THROW;");
	sb.AppendLine("    END CATCH");
	sb.AppendLine("END");
	return sb.ToString();
}

static string GenDeleteProc(ProcGenOptions options, string procSchema, string procBase, string fullTable,
	List<ColumnInfo> pkParams, ColumnInfo? rowVersionCol)
{
	var proc = $"[{procSchema}].[{procBase}_Delete]";
	var parameters = pkParams.Select(ParamDecl).ToList();
	if (rowVersionCol != null) parameters.Add($"@RowVersion {SqlTypeDecl(rowVersionCol)}");

	var wherePk = string.Join(" AND ", pkParams.Select(c => $"t.[{c.Name}] = @{c.Name}"));

	var sb = new StringBuilder();
	sb.AppendLine($"CREATE OR ALTER PROCEDURE {proc}");
	sb.AppendLine("    " + string.Join(",\r\n    ", parameters));
	sb.AppendLine("AS");
	sb.AppendLine("BEGIN");
	sb.AppendLine("    SET NOCOUNT ON; SET XACT_ABORT ON;");
	sb.AppendLine("    BEGIN TRY");
	sb.AppendLine("        BEGIN TRAN;");
	sb.AppendLine($"        DELETE FROM {fullTable} WHERE {wherePk}");
	if (rowVersionCol != null) sb.AppendLine($"        AND [{rowVersionCol.Name}] = @RowVersion");
	sb.AppendLine(";");
	sb.AppendLine("        IF @@ROWCOUNT = 0 THROW 50003, 'Delete failed (not found or concurrency conflict).', 1;");

	if (options.IncludeRowsAffected)
		sb.AppendLine("        SELECT @@ROWCOUNT AS RowsAffected;");

	sb.AppendLine("        COMMIT;");
	sb.AppendLine("    END TRY");
	sb.AppendLine("    BEGIN CATCH");
	sb.AppendLine("        IF @@TRANCOUNT > 0 ROLLBACK; THROW;");
	sb.AppendLine("    END CATCH");
	sb.AppendLine("END");
	return sb.ToString();
}

static string GenPurgeProc(ProcGenOptions options, string procSchema, string procBase, string fullTable,
	List<ColumnInfo> pkParams, ColumnInfo? rowVersionCol)
{
	var proc = $"[{procSchema}].[{procBase}_Purge]";
	var parameters = pkParams.Select(ParamDecl).ToList();
	if (rowVersionCol != null) parameters.Add($"@RowVersion {SqlTypeDecl(rowVersionCol)}");

	var wherePk = string.Join(" AND ", pkParams.Select(c => $"t.[{c.Name}] = @{c.Name}"));

	var sb = new StringBuilder();
	sb.AppendLine($"-- PERMANENT HARD DELETE");
	sb.AppendLine($"CREATE OR ALTER PROCEDURE {proc}");
	sb.AppendLine("    " + string.Join(",\r\n    ", parameters));
	sb.AppendLine("AS");
	sb.AppendLine("BEGIN");
	sb.AppendLine("    SET NOCOUNT ON; SET XACT_ABORT ON;");
	sb.AppendLine($"    DELETE FROM {fullTable} WHERE {wherePk}");
	if (rowVersionCol != null) sb.AppendLine($"    AND [{rowVersionCol.Name}] = @RowVersion");
	sb.AppendLine(";");
	sb.AppendLine("    SELECT @@ROWCOUNT AS RowsAffected;");
	sb.AppendLine("END");
	return sb.ToString();
}

static string GenGetByIdProc(string procSchema, string procBase, string fullTable, List<ColumnInfo> pkParams, bool hasSoftDelete, ColumnInfo? isDeletedCol)
{
	var proc = $"[{procSchema}].[{procBase}_GetById]";
	var where = string.Join(" AND ", pkParams.Select(c => $"t.[{c.Name}] = @{c.Name}"));
	if (hasSoftDelete) where += $" AND t.[{isDeletedCol!.Name}] = 0";

	var sb = new StringBuilder();
	sb.AppendLine($"CREATE OR ALTER PROCEDURE {proc}");
	sb.AppendLine("    " + string.Join(",\r\n    ", pkParams.Select(ParamDecl)));
	sb.AppendLine("AS");
	sb.AppendLine("BEGIN");
	sb.AppendLine("    SET NOCOUNT ON;");
	sb.AppendLine($"    SELECT * FROM {fullTable} t WHERE {where};");
	sb.AppendLine("END");
	return sb.ToString();
}

static string GenListPagedProc(ProcGenOptions options, string procSchema, string procBase, string fullTable,
	List<ColumnInfo> cols, List<ColumnInfo> pkParams, bool hasSoftDelete, ColumnInfo? isDeletedCol)
{
	var proc = $"[{procSchema}].[{procBase}_ListPaged]";
	var orderCols = pkParams.Any() ? pkParams.Select(c => $"t.[{c.Name}]") : new[] { $"t.[{cols.First(c => !c.IsComputed).Name}]" };

	var sb = new StringBuilder();
	sb.AppendLine($"CREATE OR ALTER PROCEDURE {proc}");
	sb.AppendLine("    @Skip int = 0,");
	sb.AppendLine("    @Take int = 100");
	sb.AppendLine("AS");
	sb.AppendLine("BEGIN");
	sb.AppendLine("    SET NOCOUNT ON;");
	sb.AppendLine("    IF @Skip < 0 SET @Skip = 0;");
	sb.AppendLine("    IF @Take <= 0 OR @Take > 1000 SET @Take = 100;");
	sb.AppendLine();
	sb.AppendLine($"    SELECT * FROM {fullTable} t");
	if (hasSoftDelete) sb.AppendLine($"    WHERE t.[{isDeletedCol!.Name}] = 0");
	sb.AppendLine($"    ORDER BY {string.Join(", ", orderCols)}");
	sb.AppendLine("    OFFSET @Skip ROWS FETCH NEXT @Take ROWS ONLY;");
	sb.AppendLine("END");
	return sb.ToString();
}

static string GenSelectAllProc(string procSchema, string procBase, string fullTable, bool hasSoftDelete, ColumnInfo? isDeletedCol)
{
	var sb = new StringBuilder();
	sb.AppendLine($"CREATE OR ALTER PROCEDURE [{procSchema}].[{procBase}_SelectAll]");
	sb.AppendLine("AS");
	sb.AppendLine("BEGIN");
	sb.AppendLine("    SET NOCOUNT ON;");
	sb.AppendLine($"    SELECT * FROM {fullTable} t");
	if (hasSoftDelete) sb.AppendLine($"    WHERE t.[{isDeletedCol!.Name}] = 0");
	sb.AppendLine("END");
	return sb.ToString();
}

static string GenSearchProc(string procSchema, string procBase, string fullTable, List<ColumnInfo> cols, bool hasSoftDelete, ColumnInfo? isDeletedCol)
{
	var searchable = cols.Where(c =>
		c.SqlType.IndexOf("char", StringComparison.OrdinalIgnoreCase) >= 0 ||
		c.SqlType.IndexOf("text", StringComparison.OrdinalIgnoreCase) >= 0)
		.Take(5).ToList();

	var sb = new StringBuilder();
	sb.AppendLine($"CREATE OR ALTER PROCEDURE [{procSchema}].[{procBase}_Search]");
	sb.AppendLine("    @Search nvarchar(200) = NULL,");
	sb.AppendLine("    @Skip int = 0,");
	sb.AppendLine("    @Take int = 100");
	sb.AppendLine("AS");
	sb.AppendLine("BEGIN");
	sb.AppendLine("    SET NOCOUNT ON;");
	sb.AppendLine("    IF @Skip < 0 SET @Skip = 0;");
	sb.AppendLine("    IF @Take <= 0 OR @Take > 1000 SET @Take = 100;");

	sb.AppendLine($"    SELECT * FROM {fullTable} t");
	if (searchable.Any())
	{
		var conditions = string.Join(" OR ", searchable.Select(c => $"[{c.Name}] LIKE '%' + @Search + '%'"));
		sb.AppendLine("    WHERE (@Search IS NULL OR (" + conditions + "))");
	}
	if (hasSoftDelete)
		sb.AppendLine($"      AND t.[{isDeletedCol!.Name}] = 0");
	sb.AppendLine("    ORDER BY (SELECT NULL)");
	sb.AppendLine("    OFFSET @Skip ROWS FETCH NEXT @Take ROWS ONLY;");
	sb.AppendLine("END");
	return sb.ToString();
}

// ─────────────────────────────────────────────
// HELPERS
// ─────────────────────────────────────────────
static string ParamDecl(ColumnInfo c) => $"@{c.Name} {SqlTypeDecl(c)}{(c.IsNullable ? " = NULL" : "")}";

static string SqlTypeDecl(ColumnInfo c)
{
	var t = c.SqlType.ToLowerInvariant();
	return t switch
	{
		"varchar" or "char" or "varbinary" or "binary" => $"{t}({Len(c.MaxLength)})",
		"nvarchar" or "nchar" => $"{t}({NLen(c.MaxLength)})",
		"decimal" or "numeric" => $"{t}({c.Precision},{c.Scale})",
		"datetime2" or "datetimeoffset" or "time" => $"{t}({c.Scale})",
		_ => t
	};
}

static string Len(int? maxLength) => maxLength is null or -1 ? "MAX" : maxLength.Value.ToString();
static string NLen(int? maxLength) => maxLength is null or -1 ? "MAX" : (maxLength.Value / 2).ToString();

static bool MatchesPatterns(string value, string[] patterns, bool defaultWhenEmpty) =>
	patterns.Length == 0 ? defaultWhenEmpty : patterns.Any(p => value.IndexOf(p, StringComparison.OrdinalIgnoreCase) >= 0);

static string SimplePluralize(string s) =>
	s.EndsWith("y", StringComparison.OrdinalIgnoreCase) ? s[..^1] + "ies" :
	s.EndsWith("s", StringComparison.OrdinalIgnoreCase) ? s + "es" :
	s + "s";