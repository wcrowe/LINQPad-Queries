<Query Kind="Program">
  <Connection>
    <ID>87b6df13-2c94-4d97-bd8d-077b419ecd46</ID>
    <NamingServiceVersion>3</NamingServiceVersion>
    <Persist>true</Persist>
    <Server>localhost</Server>
    <AllowDateOnlyTimeOnly>true</AllowDateOnlyTimeOnly>
    <UseMicrosoftDataSqlClient>true</UseMicrosoftDataSqlClient>
    <EncryptTraffic>true</EncryptTraffic>
    <Database>NW</Database>
    <MapXmlToString>false</MapXmlToString>
    <DriverData>
      <SkipCertificateCheck>true</SkipCertificateCheck>
    </DriverData>
  </Connection>
  <NuGetReference>Microsoft.Data.SqlClient</NuGetReference>
  <NuGetReference>Dapper</NuGetReference>
  <Namespace>Dapper</Namespace>
  <Namespace>SqlCommand = Microsoft.Data.SqlClient.SqlCommand</Namespace>
  <Namespace>SqlConnection = Microsoft.Data.SqlClient.SqlConnection</Namespace>
  <Namespace>System.Threading.Tasks</Namespace>
</Query>

#nullable enable
/*
You are an expert C# and SQL Server developer. Your task is to maintain a LINQPad script that generates calls to existing stored procedures. Will be using Dapper.


This script:
- Outputs everything to LINQPad results with the option to save to the path C:\dev\GeneratedModels

Rules you MUST follow:
- NEVER break existing functionality. The script must still generate the same correct source as before.
- Output only the full updated script — nothing else.
- Do not change options or exclusions unless explicitly asked.
- Test logic for composite
--Use Best Practices for NET 10 and LINQPad 9

*/

//TODO: Option Fluent API configuration(EF Core)
//TODO: Option Separate file per class
//TODO:  Option to add JSON attributes([JsonPropertyName])
//TODO: Last explore adding Inheritance/ base class



using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.Data.SqlClient;

// ────────────────────────────────────────────────────────────────────────────────
// CONFIGURATION
// ────────────────────────────────────────────────────────────────────────────────
const bool SaveToDisk = true;
readonly string OutputDir = @"C:\dev\GeneratedModels"; // Change as needed

// Include all tables, or filter here:
// static readonly HashSet<string> IncludeSchemas = new() { "dbo" };
// static readonly HashSet<string> ExcludeTables = new() { "sysdiagrams", "MigrationHistory" };

static readonly HashSet<string> IncludeSchemas = new(); // empty = all
static readonly HashSet<string> ExcludeTables = new();  // empty = none

const string Namespace = "MyApp.Models";
const bool UseRecords = true; // true = record class, false = class
const bool AddDataAnnotations = true;
const bool AddKeyAttribute = true;

// ────────────────────────────────────────────────────────────────────────────────
// MAIN
// ────────────────────────────────────────────────────────────────────────────────
async Task Main()
{
	Directory.CreateDirectory(OutputDir);

	var connectionString = Connection.ConnectionString;
	var tables = await LoadTableMetadataAsync(connectionString);

	var sb = new StringBuilder();
	sb.AppendLine("// <auto-generated />");
	sb.AppendLine("#nullable enable");
	sb.AppendLine("using System;");
	sb.AppendLine("using System.ComponentModel.DataAnnotations;");
	sb.AppendLine();
	sb.AppendLine($"namespace {Namespace};");
	sb.AppendLine();

	foreach (var table in tables.OrderBy(t => t.ClassName))
	{
		sb.AppendLine(GenerateClass(table));
		sb.AppendLine();
	}

	sb.ToString().Dump("Generated POCOs");

	if (SaveToDisk)
	{
		var filePath = Path.Combine(OutputDir, "Models.g.cs");
		await File.WriteAllTextAsync(filePath, sb.ToString());
		filePath.Dump("Saved to");
	}

	tables.Count.Dump("Tables generated");
}

// ────────────────────────────────────────────────────────────────────────────────
// MODEL
// ────────────────────────────────────────────────────────────────────────────────
record TableInfo(
	string Schema,
	string TableName,
	string ClassName,
	List<ColumnInfo> Columns,
	bool HasPrimaryKey
);

record ColumnInfo(
	string ColumnName,
	string PropertyName,
	string CSharpType,
	bool IsNullable,
	bool IsPrimaryKey,
	int? MaxLength,
	bool HasDefault // Helps decide if [Required] is truly needed
);

// ────────────────────────────────────────────────────────────────────────────────
// LOAD METADATA
// ────────────────────────────────────────────────────────────────────────────────
async Task<List<TableInfo>> LoadTableMetadataAsync(string connectionString)
{
	const string sql = @"
SELECT 
    t.TABLE_SCHEMA,
    t.TABLE_NAME,
    c.COLUMN_NAME,
    c.DATA_TYPE,
    c.CHARACTER_MAXIMUM_LENGTH,
    c.IS_NULLABLE,
    c.COLUMN_DEFAULT,
    CASE WHEN pk.COLUMN_NAME IS NOT NULL THEN 1 ELSE 0 END AS IsPrimaryKey
FROM INFORMATION_SCHEMA.TABLES t
JOIN INFORMATION_SCHEMA.COLUMNS c 
    ON t.TABLE_SCHEMA = c.TABLE_SCHEMA AND t.TABLE_NAME = c.TABLE_NAME
LEFT JOIN (
    SELECT ku.TABLE_SCHEMA, ku.TABLE_NAME, ku.COLUMN_NAME
    FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE ku
        ON tc.CONSTRAINT_NAME = ku.CONSTRAINT_NAME
    WHERE tc.CONSTRAINT_TYPE = 'PRIMARY KEY'
) pk
    ON c.TABLE_SCHEMA = pk.TABLE_SCHEMA 
   AND c.TABLE_NAME = pk.TABLE_NAME 
   AND c.COLUMN_NAME = pk.COLUMN_NAME
WHERE t.TABLE_TYPE = 'BASE TABLE'
ORDER BY t.TABLE_SCHEMA, t.TABLE_NAME, c.ORDINAL_POSITION;";

	await using var conn = new SqlConnection(connectionString);
	await conn.OpenAsync();

	var rows = await conn.QueryAsync(sql);

	var grouped = rows.GroupBy(r => new { Schema = (string)r.TABLE_SCHEMA, Table = (string)r.TABLE_NAME })
		.Select(g =>
		{
			var className = ToPascalCase(g.Key.Table);
			if (char.IsDigit(className[0])) className = "_" + className;

			var columns = g.Select(r => new ColumnInfo(
				ColumnName: (string)r.COLUMN_NAME,
				PropertyName: ToPascalCase((string)r.COLUMN_NAME),
				CSharpType: MapSqlTypeToCSharp((string)r.DATA_TYPE, (string)r.IS_NULLABLE == "YES"),
				IsNullable: (string)r.IS_NULLABLE == "YES",
				IsPrimaryKey: (int)r.IsPrimaryKey == 1,
				MaxLength: r.CHARACTER_MAXIMUM_LENGTH as int?,
				HasDefault: r.COLUMN_DEFAULT != null
			)).ToList();

			var hasPk = columns.Any(c => c.IsPrimaryKey);

			return new TableInfo(g.Key.Schema, g.Key.Table, className, columns, hasPk);
		})
		.Where(t => IncludeSchemas.Count == 0 || IncludeSchemas.Contains(t.Schema))
		.Where(t => !ExcludeTables.Contains(t.TableName))
		.ToList();

	return grouped;
}

// ────────────────────────────────────────────────────────────────────────────────
// CODE GENERATION
// ────────────────────────────────────────────────────────────────────────────────
string GenerateClass(TableInfo table)
{
	var sb = new StringBuilder();

	sb.AppendLine($"/// <summary>");
	sb.AppendLine($"/// Represents the [{table.Schema}].[{table.TableName}] table.");
	sb.AppendLine($"/// </summary>");

	if (AddKeyAttribute && table.HasPrimaryKey)
		sb.AppendLine("[System.ComponentModel.DataAnnotations.Schema.Table(\"{table.TableName}\", Schema = \"{table.Schema}\")]");

	var recordOrClass = UseRecords ? "record" : "class";
	sb.AppendLine($"public {(UseRecords ? "sealed" : "")} {recordOrClass} {table.ClassName}");
	sb.AppendLine("{");

	foreach (var col in table.Columns)
	{
		// Attributes
		if (AddDataAnnotations)
		{
			if (AddKeyAttribute && col.IsPrimaryKey)
				sb.AppendLine("\t[Key]");

			if (!col.IsNullable && !col.HasDefault && col.CSharpType != "string") // string is reference type, always 'required' in a sense
				sb.AppendLine("\t[Required]");

			if (col.MaxLength.HasValue && col.MaxLength.Value > 0 && (col.CSharpType == "string" || col.CSharpType == "string?"))
			{
				var len = col.MaxLength.Value == -1 ? "Max" : col.MaxLength.Value.ToString();
				sb.AppendLine($"\t[StringLength({len})]");
			}
		}

		// Property
		sb.AppendLine($"\tpublic {col.CSharpType} {col.PropertyName} {{ get; init; }} // {col.ColumnName}");

		sb.AppendLine();
	}

	sb.Append("}");

	return sb.ToString();
}

// ────────────────────────────────────────────────────────────────────────────────
// HELPERS
// ────────────────────────────────────────────────────────────────────────────────
static string ToPascalCase(string name)
{
	if (string.IsNullOrEmpty(name)) return name;

	var parts = name.Split(new[] { '_', ' ' }, StringSplitOptions.RemoveEmptyEntries);
	return string.Join("", parts.Select(p => char.ToUpperInvariant(p[0]) + p.Substring(1).ToLowerInvariant()));
}

static string MapSqlTypeToCSharp(string sqlType, bool isNullable)
{
	var type = sqlType.ToLowerInvariant() switch
	{
		"bigint" => "long",
		"int" => "int",
		"smallint" => "short",
		"tinyint" => "byte",
		"bit" => "bool",
		"decimal" or "numeric" or "money" or "smallmoney" => "decimal",
		"float" => "double",
		"real" => "float",
		"date" => "DateOnly",
		"time" => "TimeOnly",
		"datetime" or "datetime2" or "smalldatetime" => "DateTime",
		"datetimeoffset" => "DateTimeOffset",
		"uniqueidentifier" => "Guid",
		"binary" or "varbinary" or "image" or "timestamp" or "rowversion" => "byte[]",
		"char" or "nchar" or "varchar" or "nvarchar" or "text" or "ntext" => "string",
		"xml" => "string",
		_ => "object"
	};

	if (isNullable && type is not ("string" or "byte[]" or "object"))
		type += "?";

	return type;
}