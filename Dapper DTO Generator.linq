<Query Kind="Program">
  <Connection>
    <ID>87b6df13-2c94-4d97-bd8d-077b419ecd46</ID>
    <NamingServiceVersion>3</NamingServiceVersion>
    <Persist>true</Persist>
    <Server>localhost</Server>
    <AllowDateOnlyTimeOnly>true</AllowDateOnlyTimeOnly>
    <UseMicrosoftDataSqlClient>true</UseMicrosoftDataSqlClient>
    <EncryptTraffic>true</EncryptTraffic>
    <Database>NW</Database>
    <MapXmlToString>false</MapXmlToString>
    <DriverData>
      <SkipCertificateCheck>true</SkipCertificateCheck>
    </DriverData>
  </Connection>
  <NuGetReference>Microsoft.Data.SqlClient</NuGetReference>
  <Namespace>SqlCommand = Microsoft.Data.SqlClient.SqlCommand</Namespace>
  <Namespace>SqlConnection = Microsoft.Data.SqlClient.SqlConnection</Namespace>
</Query>

#nullable enable
// LINQPad 9 / .NET 10
// Generates Dapper DTOs (request/response POCOs) from SQL Server stored procedures.
// - Creates: <ProcName>_Request + <ProcName>_Result (if a resultset can be described)
// - Uses sp_describe_first_result_set_for_object for result schema (best effort)
// - Reads proc params from sys.parameters
// - Writes .cs files per proc and/or one combined file
//
// NOTE:
// - Some procedures return multiple result sets; SQL Server can only describe the FIRST one here.
// - If a proc uses dynamic SQL, SQL may not be able to describe the result set -> Result DTO is skipped.
// - Table-valued parameters (TVPs) are emitted as DataTable/IEnumerable placeholder comments.
//
// CONFIG defaults are safe; edit only if you want different output paths/names.

using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.Data.SqlClient;

// ─────────────────────────────────────────────
// CONFIGURATION
// ─────────────────────────────────────────────
const bool SaveToDisk = true;
readonly string OutputDir = @"C:\dev\DapperDtos";
const bool OneFilePerProc = true;      // true => one .cs per proc. false => one combined file.
const bool IncludeSchemaInClassName = false;
const bool UseNullableRefs = true;
const bool IncludeNamespace = true;
const string NamespaceName = "Generated.Dtos";
const string FileHeaderComment = "Auto-generated by LINQPad. Review before committing.";

// Optional filters
const string? ProcSchemaFilter = null; // e.g. "dbo" or null
readonly string? ProcNameLike = null;  // e.g. "%usp_Articles_%" or null

void Main()
{
	using var conn = new SqlConnection(this.Connection.ConnectionString);
	conn.Open();

	var procs = LoadStoredProcedures(conn, ProcSchemaFilter, ProcNameLike)
		.OrderBy(p => p.Schema)
		.ThenBy(p => p.Name)
		.ToList();

	if (procs.Count == 0)
	{
		"No stored procedures matched your filters.".Dump();
		return;
	}

	if (SaveToDisk) Directory.CreateDirectory(OutputDir);

	var combined = new StringBuilder();
	AppendFilePreamble(combined);

	int written = 0;

	foreach (var p in procs)
	{
		var procFull = $"[{p.Schema}].[{p.Name}]";

		var parameters = LoadProcParameters(conn, p.ObjectId)
			.Where(x => !x.IsReturnValue)
			.ToList();

		var resultCols = DescribeFirstResultSet(conn, procFull);

		var code = GenerateDtoCode(p.Schema, p.Name, parameters, resultCols);

		if (!OneFilePerProc)
		{
			combined.AppendLine(code);
			combined.AppendLine();
		}
		else
		{
			var fileName = $"{SanitizeFileName(BuildProcBaseName(p.Schema, p.Name))}.Dtos.g.cs";
			var fullPath = Path.Combine(OutputDir, fileName);

			var sb = new StringBuilder();
			AppendFilePreamble(sb);
			sb.AppendLine(code);

			if (SaveToDisk)
			{
				File.WriteAllText(fullPath, sb.ToString(), Encoding.UTF8);
				$"Wrote {fullPath}".Dump();
				written++;
			}
			else
			{
				sb.ToString().Dump(fileName);
			}
		}
	}

	if (!OneFilePerProc)
	{
		var combinedPath = Path.Combine(OutputDir, "StoredProcedureDtos.g.cs");
		if (SaveToDisk)
		{
			File.WriteAllText(combinedPath, combined.ToString(), Encoding.UTF8);
			$"Wrote {combinedPath}".Dump();
		}
		else
		{
			combined.ToString().Dump("StoredProcedureDtos.g.cs");
		}
	}

	$"Processed {procs.Count} procedures.".Dump();
}

// ─────────────────────────────────────────────
// Models
// ─────────────────────────────────────────────
record ProcInfo(int ObjectId, string Schema, string Name);

record ProcParam(
	string Name,           // without @
	string SqlTypeName,     // e.g. nvarchar, int, uniqueidentifier, etc.
	int MaxLength,          // bytes (nvarchar is bytes)
	byte Precision,
	byte Scale,
	bool IsOutput,
	bool HasDefault,
	bool IsNullable,
	bool IsTableType,
	string? TableTypeName,
	bool IsReturnValue
);

record ResultCol(
	string Name,
	string SqlTypeName,
	int MaxLength,
	byte Precision,
	byte Scale,
	bool IsNullable
);

// ─────────────────────────────────────────────
// Metadata: stored procedures
// ─────────────────────────────────────────────
static List<ProcInfo> LoadStoredProcedures(SqlConnection conn, string? schemaFilter, string? nameLike)
{
	// type = 'P' = SQL stored procedure
	// exclude system shipped
	var sql = @"
SELECT p.object_id, s.name AS schema_name, p.name AS proc_name
FROM sys.procedures p
JOIN sys.schemas s ON s.schema_id = p.schema_id
WHERE p.is_ms_shipped = 0
  AND (@schema IS NULL OR s.name = @schema)
  AND (@like IS NULL OR p.name LIKE @like)
ORDER BY s.name, p.name;";

	using var cmd = new SqlCommand(sql, conn);
	cmd.Parameters.AddWithValue("@schema", (object?)schemaFilter ?? DBNull.Value);
	cmd.Parameters.AddWithValue("@like", (object?)nameLike ?? DBNull.Value);

	using var r = cmd.ExecuteReader();
	var list = new List<ProcInfo>();
	while (r.Read())
		list.Add(new ProcInfo(r.GetInt32(0), r.GetString(1), r.GetString(2)));

	return list;
}

static List<ProcParam> LoadProcParameters(SqlConnection conn, int procObjectId)
{
	// sys.parameters + sys.types + sys.table_types (for TVP)
	// parameter_id = 0 is return value
	const string sql = @"
SELECT
	p.parameter_id,
	p.name,
	ty.name AS type_name,
	p.max_length,
	p.precision,
	p.scale,
	p.is_output,
	p.has_default_value,
	p.is_nullable,
	CASE WHEN ty.is_table_type = 1 THEN 1 ELSE 0 END AS is_table_type,
	tt.name AS table_type_name
FROM sys.parameters p
JOIN sys.types ty ON ty.user_type_id = p.user_type_id
LEFT JOIN sys.table_types tt ON tt.user_type_id = p.user_type_id
WHERE p.object_id = @objId
ORDER BY p.parameter_id;";

	using var cmd = new SqlCommand(sql, conn);
	cmd.Parameters.AddWithValue("@objId", procObjectId);

	using var r = cmd.ExecuteReader();
	var list = new List<ProcParam>();

	while (r.Read())
	{
		var paramId = r.GetInt32(0);
		var rawName = r.IsDBNull(1) ? "" : r.GetString(1);
		var name = rawName.StartsWith("@", StringComparison.Ordinal) ? rawName[1..] : rawName;

		list.Add(new ProcParam(
			Name: name,
			SqlTypeName: r.GetString(2),
			MaxLength: r.GetInt16(3),
			Precision: r.GetByte(4),
			Scale: r.GetByte(5),
			IsOutput: r.GetBoolean(6),
			HasDefault: r.GetBoolean(7),
			IsNullable: r.GetBoolean(8),
			IsTableType: r.GetInt32(9) == 1,
			TableTypeName: r.IsDBNull(10) ? null : r.GetString(10),
			IsReturnValue: paramId == 0
		));
	}

	return list;
}

// ─────────────────────────────────────────────
// Result-set description
// ─────────────────────────────────────────────
static List<ResultCol>? DescribeFirstResultSet(SqlConnection conn, string procTwoPartName)
{
	// Uses built-in system proc; best effort.
	// For procs that cannot be described (dynamic SQL), it returns an error result; we skip.
	const string sql = @"
DECLARE @objId int = OBJECT_ID(@procName);
IF @objId IS NULL
BEGIN
	SELECT CAST(1 AS bit) AS [HasError], CAST(N'OBJECT_ID not found' AS nvarchar(4000)) AS [ErrorMessage];
	RETURN;
END

BEGIN TRY
	EXEC sys.sp_describe_first_result_set_for_object @object_id = @objId, @browse_information_mode = 1;
END TRY
BEGIN CATCH
	SELECT CAST(1 AS bit) AS [HasError], ERROR_MESSAGE() AS [ErrorMessage];
END CATCH;";

	using var cmd = new SqlCommand(sql, conn);
	cmd.Parameters.AddWithValue("@procName", procTwoPartName);

	// This returns either:
	// - columns describing result set (with name/system_type_name/is_nullable etc), OR
	// - a row with HasError/ErrorMessage (our SELECT)
	// We detect based on schema.
	using var r = cmd.ExecuteReader();

	// If our error-shape comes back, it will have HasError.
	var hasHasError = false;
	for (int i = 0; i < r.FieldCount; i++)
	{
		if (string.Equals(r.GetName(i), "HasError", StringComparison.OrdinalIgnoreCase))
		{
			hasHasError = true;
			break;
		}
	}

	if (hasHasError)
	{
		if (r.Read())
		{
			var msg = r["ErrorMessage"]?.ToString() ?? "Unknown error";
			$"Result-set not describable for {procTwoPartName} (skipping Result DTO): {msg}".Dump();
		}
		return null;
	}

	// sp_describe_first_result_set_for_object columns:
	// name, system_type_name, max_length, precision, scale, is_nullable, etc.
	int idxName = SafeGetOrdinal(r, "name");
	int idxType = SafeGetOrdinal(r, "system_type_name");
	int idxLen = SafeGetOrdinal(r, "max_length");
	int idxPrec = SafeGetOrdinal(r, "precision");
	int idxScale = SafeGetOrdinal(r, "scale");
	int idxNull = SafeGetOrdinal(r, "is_nullable");

	if (idxName < 0 || idxType < 0) return null;

	var cols = new List<ResultCol>();
	while (r.Read())
	{
		var colName = r.IsDBNull(idxName) ? null : r.GetString(idxName);
		if (string.IsNullOrWhiteSpace(colName)) continue;

		var sysType = r.IsDBNull(idxType) ? "sql_variant" : r.GetString(idxType);

		cols.Add(new ResultCol(
			Name: colName!,
			SqlTypeName: NormalizeSystemTypeName(sysType),
			MaxLength: idxLen >= 0 && !r.IsDBNull(idxLen) ? Convert.ToInt32(r.GetValue(idxLen)) : -1,
			Precision: (byte)(idxPrec >= 0 && !r.IsDBNull(idxPrec) ? Convert.ToInt32(r.GetValue(idxPrec)) : 0),
			Scale: (byte)(idxScale >= 0 && !r.IsDBNull(idxScale) ? Convert.ToInt32(r.GetValue(idxScale)) : 0),
			IsNullable: idxNull >= 0 && !r.IsDBNull(idxNull) && Convert.ToBoolean(r.GetValue(idxNull))
		));
	}

	return cols;
}

static int SafeGetOrdinal(SqlDataReader r, string colName)
{
	for (int i = 0; i < r.FieldCount; i++)
		if (string.Equals(r.GetName(i), colName, StringComparison.OrdinalIgnoreCase))
			return i;
	return -1;
}

static string NormalizeSystemTypeName(string systemTypeName)
{
	// Examples from sp_describe_first_result_set_for_object:
	// "nvarchar(50)", "decimal(18,2)", "int", "uniqueidentifier", "datetime2(7)", etc.
	// We'll strip size/precision later; but keep the base for mapping.
	var s = systemTypeName.Trim();
	var paren = s.IndexOf('(');
	return paren > 0 ? s[..paren].Trim() : s;
}

// ─────────────────────────────────────────────
// Code generation
// ─────────────────────────────────────────────
static string GenerateDtoCode(string schema, string procName, List<ProcParam> parameters, List<ResultCol>? resultCols)
{
	var baseName = BuildProcBaseName(schema, procName);

	var requestName = $"{baseName}_Request";
	var resultName = $"{baseName}_Result";

	var sb = new StringBuilder();

	if (IncludeNamespace)
	{
		sb.AppendLine($"namespace {NamespaceName};");
		sb.AppendLine();
	}

	// REQUEST DTO
	sb.AppendLine($"public sealed record {requestName}");
	sb.AppendLine("{");

	if (parameters.Count == 0)
	{
		sb.AppendLine("}");
		sb.AppendLine();
	}
	else
	{
		foreach (var p in parameters)
		{
			var csharpType = MapSqlToCSharpForParam(p);
			var propName = ToPascalIdentifier(p.Name);

			if (p.IsTableType)
			{
				sb.AppendLine($"    // TVP {p.TableTypeName ?? "(unknown)"}: consider DataTable or IEnumerable<YourRowType>");
			}

			sb.AppendLine($"    public {csharpType} {propName} {{ get; init; }}{(UseNullableRefs ? " = default!" : "")}");
		}
		sb.AppendLine("}");
		sb.AppendLine();
	}

	// RESULT DTO (best-effort)
	if (resultCols is { Count: > 0 })
	{
		sb.AppendLine($"public sealed record {resultName}");
		sb.AppendLine("{");

		foreach (var c in resultCols)
		{
			var csharpType = MapSqlToCSharpForResult(c);
			var propName = ToPascalIdentifier(c.Name);
			sb.AppendLine($"    public {csharpType} {propName} {{ get; init; }}{(UseNullableRefs ? " = default!" : "")}");
		}

		sb.AppendLine("}");
		sb.AppendLine();
	}
	else
	{
		sb.AppendLine($"// NOTE: Result DTO not generated for {schema}.{procName} (no describable first result set).");
		sb.AppendLine();
	}

	return sb.ToString();
}

static string BuildProcBaseName(string schema, string procName)
{
	var n = procName;
	if (IncludeSchemaInClassName)
		n = $"{schema}_{n}";

	// Typical preference: strip "usp_" prefix
	if (n.StartsWith("usp_", StringComparison.OrdinalIgnoreCase))
		n = n[4..];

	// Make it PascalCase-ish with underscores as boundaries
	return ToPascalIdentifier(n);
}

static string ToPascalIdentifier(string input)
{
	if (string.IsNullOrWhiteSpace(input)) return "Unnamed";

	// Replace non-letter/digit with underscores, then PascalCase segments
	var cleaned = new string(input.Select(ch => char.IsLetterOrDigit(ch) ? ch : '_').ToArray());
	var parts = cleaned.Split(new[] { '_' }, StringSplitOptions.RemoveEmptyEntries);

	var sb = new StringBuilder();
	foreach (var part in parts)
	{
		if (part.Length == 0) continue;
		sb.Append(char.ToUpperInvariant(part[0]));
		if (part.Length > 1) sb.Append(part.Substring(1));
	}

	var id = sb.Length == 0 ? "Unnamed" : sb.ToString();

	// If starts with digit, prefix
	if (char.IsDigit(id[0])) id = "P" + id;
	return id;
}

static string SanitizeFileName(string s)
{
	foreach (var c in Path.GetInvalidFileNameChars())
		s = s.Replace(c, '_');
	return s;
}

// ─────────────────────────────────────────────
// Type mapping
// ─────────────────────────────────────────────
static string MapSqlToCSharpForParam(ProcParam p)
{
	// For proc params we map base SQL type names
	var sql = p.SqlTypeName.ToLowerInvariant();

	// TVP placeholder
	if (p.IsTableType)
		return UseNullableRefs ? "object?" : "object";

	string cs = sql switch
	{
		"int" => "int",
		"bigint" => "long",
		"smallint" => "short",
		"tinyint" => "byte",
		"bit" => "bool",
		"uniqueidentifier" => "Guid",
		"float" => "double",
		"real" => "float",
		"decimal" or "numeric" or "money" or "smallmoney" => "decimal",
		"date" or "datetime" or "datetime2" or "smalldatetime" => "DateTime",
		"datetimeoffset" => "DateTimeOffset",
		"time" => "TimeSpan",
		"char" or "varchar" or "nchar" or "nvarchar" or "text" or "ntext" => "string",
		"binary" or "varbinary" or "image" => "byte[]",
		"xml" => "string",
		"sql_variant" => UseNullableRefs ? "object?" : "object",
		"rowversion" or "timestamp" => "byte[]",
		_ => UseNullableRefs ? "object?" : "object"
	};

	// Apply nullability
	// - Reference types: add ? if nullable refs enabled
	// - Value types: add ? if nullable
	bool isValueType =
		cs is "int" or "long" or "short" or "byte" or "bool" or "Guid" or "double" or "float" or "decimal" or "DateTime" or "DateTimeOffset" or "TimeSpan";

	if (isValueType)
		return p.IsNullable ? cs + "?" : cs;

	if (UseNullableRefs)
	{
		// string/byte[]/object are reference types
		return p.IsNullable ? cs + "?" : cs;
	}

	return cs;
}

static string MapSqlToCSharpForResult(ResultCol c)
{
	var sql = c.SqlTypeName.ToLowerInvariant();

	string cs = sql switch
	{
		"int" => "int",
		"bigint" => "long",
		"smallint" => "short",
		"tinyint" => "byte",
		"bit" => "bool",
		"uniqueidentifier" => "Guid",
		"float" => "double",
		"real" => "float",
		"decimal" or "numeric" or "money" or "smallmoney" => "decimal",
		"date" or "datetime" or "datetime2" or "smalldatetime" => "DateTime",
		"datetimeoffset" => "DateTimeOffset",
		"time" => "TimeSpan",
		"char" or "varchar" or "nchar" or "nvarchar" or "text" or "ntext" => "string",
		"binary" or "varbinary" or "image" => "byte[]",
		"xml" => "string",
		"sql_variant" => UseNullableRefs ? "object?" : "object",
		"rowversion" or "timestamp" => "byte[]",
		_ => UseNullableRefs ? "object?" : "object"
	};

	bool isValueType =
		cs is "int" or "long" or "short" or "byte" or "bool" or "Guid" or "double" or "float" or "decimal" or "DateTime" or "DateTimeOffset" or "TimeSpan";

	if (isValueType)
		return c.IsNullable ? cs + "?" : cs;

	if (UseNullableRefs)
		return c.IsNullable ? cs + "?" : cs;

	return cs;
}

// ─────────────────────────────────────────────
// File preamble
// ─────────────────────────────────────────────
static void AppendFilePreamble(StringBuilder sb)
{
	sb.AppendLine("// <auto-generated>");
	sb.AppendLine($"// {FileHeaderComment}");
	sb.AppendLine("// </auto-generated>");
	sb.AppendLine();
	sb.AppendLine("#nullable enable");
	sb.AppendLine();
	sb.AppendLine("using System;");
	sb.AppendLine("using System.Collections.Generic;");
	sb.AppendLine();
}
